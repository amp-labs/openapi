# See Makefile for the commands that generate Go types from this file.
# This file is referenced by api.yaml.
openapi: 3.0.1
info:
  title: Integration manifest
  version: 1.0.0
  license:
    name: MIT License
    url: https://opensource.org/license/mit
servers: []
paths: {}

components:
  schemas:
    Manifest:
      type: object
      description: This is the schema of the manifest file that is used to define the integrations of the project.
      required:
        - specVersion
        - integrations
      properties:
        specVersion:
          type: string
          description: The version of the manifest spec that this file conforms to.
        integrations:
          type: array
          items:
            $ref: '#/components/schemas/Integration'

    Integration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/IntegrationRead'
        write:
          $ref: '#/components/schemas/IntegrationWrite'
        proxy:
          $ref: '#/components/schemas/IntegrationProxy'

    IntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    IntegrationRead:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationObject'

    IntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to IntegrationReadObject if appropriate.
    IntegrationObject:
      type: object
      required:
        - objectName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/IntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'
        backfill:
          $ref: '#/components/schemas/Backfill'
        delivery:
          $ref: '#/components/schemas/Delivery'

    # We might end up using the same IntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    IntegrationWriteObject:
      type: object
      required:
        - objectName
      properties:
        objectName:
          type: string
        inheritMappingFromRead:
          type: boolean
          description: If true, the write object will inherit the mapping from the read object. If false, the write object will have no mapping.
          example: true

    HydratedIntegration:
      type: object
      required:
        - name
        - provider
      properties:
        name:
          type: string
        displayName:
          type: string
        provider:
          type: string
        read:
          $ref: '#/components/schemas/HydratedIntegrationRead'
        write:
          $ref: '#/components/schemas/HydratedIntegrationWrite'
        proxy:
          $ref: '#/components/schemas/HydratedIntegrationProxy'

    HydratedIntegrationProxy:
      type: object
      properties:
        enabled:
          type: boolean

    HydratedIntegrationRead:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationObject'

    HydratedIntegrationWrite:
      type: object
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationWriteObject'

    # This is currently only used for read actions.
    # Once we figure out whether to share the same type for both read and write, or use
    # different types, we can rename this to HydratedIntegrationReadObject if appropriate.
    HydratedIntegrationObject:
      type: object
      required:
        - objectName
        - displayName
        - destination
        - schedule
      properties:
        objectName:
          type: string
        displayName:
          type: string
        destination:
          type: string
        schedule:
          type: string
        requiredFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFields:
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        optionalFieldsAuto:
          $ref: '#/components/schemas/OptionalFieldsAutoOption'
        allFields:
          description: This is a list of all fields on the object for a particular SaaS instance. This is used to populate the UI during configuration.
          type: array
          items:
            $ref: '#/components/schemas/HydratedIntegrationField'
        backfill:
          $ref: '#/components/schemas/Backfill'

    # We might end up using the same HydratedIntegrationObject type for both read and write,
    # but for now we're introducing a new type to keep them separate, and not renaming the
    # existing IntegrationObject.
    HydratedIntegrationWriteObject:
      type: object
      required:
        - objectName
        - displayName
      properties:
        objectName:
          type: string
        displayName:
          type: string

    OptionalFieldsAutoOption:
      type: string
      enum: [all]

    IntegrationField:
      oneOf:
        - $ref: '#/components/schemas/IntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    IntegrationFieldExistent:
      type: object
      required:
        - fieldName
      properties:
        fieldName:
          type: string
        mapToName:
          type: string
          description: The field name to map to in the destination.
          example: account_id

    IntegrationFieldMapping:
      type: object
      required:
        - mapToName
      properties:
        mapToName:
          type: string
        mapToDisplayName:
          type: string
        default:
          type: string
        prompt:
          type: string

    HydratedIntegrationField:
      oneOf:
        - $ref: '#/components/schemas/HydratedIntegrationFieldExistent'
        - $ref: '#/components/schemas/IntegrationFieldMapping'

    HydratedIntegrationFieldExistent:
      type: object
      required:
        - fieldName
        - displayName
      properties:
        fieldName:
          type: string
        displayName:
          type: string

    Backfill:
      type: object
      required:
        - defaultPeriod
      properties:
        defaultPeriod:
          $ref: '#/components/schemas/DefaultPeriod'

    DefaultPeriod:
      type: object
      properties:
        days:
          type: integer
          description: Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
          minimum: 0
          example: 30
          x-oapi-codegen-extra-tags:
            validate: required_without=FullHistory,omitempty,min=0
        fullHistory:
          type: boolean
          description: If true, backfill all history. Required if days is not set.
          example: false
          x-oapi-codegen-extra-tags:
            validate: required_without=Days

    Delivery:
      type: object
      properties:
        mode:
          type: string
          default: auto
          enum: [onRequest, auto]
          description: The data delivery mode for this object. If not specified, defaults to automatic.
        pageSize:
            type: integer
            description: The number of records to receive per data delivery.
            minimum: 50
            maximum: 500